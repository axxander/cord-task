import { readFileSync, truncate } from 'fs';
import { resolve } from 'path';

import bodyParser from 'body-parser';

import { validate } from '../utils/typing.util';
import { BadRequestError } from '../errors';

// Assume no errors thrown: would check all cases before prod
const rules = JSON.parse(readFileSync(resolve(__dirname, './rules.json')));

export default function (app) {
    app.set('port', process.env.PORT || 3000);
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({ extended: true }));
}

/**
 * TBD: middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw a 400 code error with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */
export const checkAgainstRules = (req, res, next) => {
    const requestMethod = req.method.toLowerCase();
    const requestPath = req.baseUrl.concat(req.path);
    const path = rules.paths[requestPath];

    // Only concerned with paths + methods specified within rules
    if (path && path[requestMethod]) {
        // Get valid parameters + rules for path + method combination
        const validQueryParamsRules = path[requestMethod].parameters;
        const validQueryParamsNames = validQueryParamsRules.map((p) => p.name);

        for (const [param, value] of Object.entries(req.query)) {
            // Check param is not extraneous
            if (!validQueryParamsNames.includes(param)) {
                return next(
                    new BadRequestError(
                        `\`${param}\` is not a valid query parameter`
                    )
                );
            }

            // Validate non-extraneous param
            const schema = validQueryParamsRules.find((p) => p.name === param);
            if (!validate(schema, value)) {
                return next(
                    new BadRequestError(
                        `query parameter \`${param}\` has an invalid type`
                    )
                );
            }
        }
    }
    // default for all other route/method combinations
    return next();
};
